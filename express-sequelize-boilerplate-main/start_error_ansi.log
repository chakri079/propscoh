[EXPRESS] Express initialized
[AWS] AWS service initialized
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='addresses';
Executing (default): PRAGMA TABLE_INFO(`addresses`);
Executing (default): PRAGMA foreign_key_list(`addresses`)
Executing (default): PRAGMA INDEX_LIST(`addresses`)
Executing (default): PRAGMA foreign_key_list(`addresses`)
Executing (default): PRAGMA TABLE_INFO(`addresses`);
Executing (default): PRAGMA INDEX_LIST(`addresses`)
Executing (default): PRAGMA foreign_key_list(`addresses`)
Executing (default): CREATE TABLE IF NOT EXISTS `addresses_backup` (`id` INTEGER PRIMARY KEY, `city` VARCHAR(255), `state` VARCHAR(255), `neighborhood` VARCHAR(255), `country` VARCHAR(255), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `addresses_backup` SELECT `id`, `city`, `state`, `neighborhood`, `country`, `created_at`, `updated_at` FROM `addresses`;
Executing (default): DROP TABLE `addresses`;
Executing (default): CREATE TABLE IF NOT EXISTS `addresses` (`id` INTEGER PRIMARY KEY, `city` VARCHAR(255), `state` VARCHAR(255), `neighborhood` VARCHAR(255), `country` VARCHAR(255), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `addresses` SELECT `id`, `city`, `state`, `neighborhood`, `country`, `created_at`, `updated_at` FROM `addresses_backup`;
Executing (default): DROP TABLE `addresses_backup`;
Executing (default): PRAGMA TABLE_INFO(`addresses`);
Executing (default): PRAGMA INDEX_LIST(`addresses`)
Executing (default): PRAGMA foreign_key_list(`addresses`)
Executing (default): CREATE TABLE IF NOT EXISTS `addresses_backup` (`id` INTEGER PRIMARY KEY, `city` VARCHAR(255), `state` VARCHAR(255), `neighborhood` VARCHAR(255), `country` VARCHAR(255), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `addresses_backup` SELECT `id`, `city`, `state`, `neighborhood`, `country`, `created_at`, `updated_at` FROM `addresses`;
Executing (default): DROP TABLE `addresses`;
Executing (default): CREATE TABLE IF NOT EXISTS `addresses` (`id` INTEGER PRIMARY KEY, `city` VARCHAR(255), `state` VARCHAR(255), `neighborhood` VARCHAR(255), `country` VARCHAR(255), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `addresses` SELECT `id`, `city`, `state`, `neighborhood`, `country`, `created_at`, `updated_at` FROM `addresses_backup`;
Executing (default): DROP TABLE `addresses_backup`;
Executing (default): PRAGMA TABLE_INFO(`addresses`);
Executing (default): PRAGMA INDEX_LIST(`addresses`)
Executing (default): PRAGMA foreign_key_list(`addresses`)
Executing (default): CREATE TABLE IF NOT EXISTS `addresses_backup` (`id` INTEGER PRIMARY KEY, `city` VARCHAR(255), `state` VARCHAR(255), `neighborhood` VARCHAR(255), `country` VARCHAR(255), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `addresses_backup` SELECT `id`, `city`, `state`, `neighborhood`, `country`, `created_at`, `updated_at` FROM `addresses`;
Executing (default): DROP TABLE `addresses`;
Executing (default): CREATE TABLE IF NOT EXISTS `addresses` (`id` INTEGER PRIMARY KEY, `city` VARCHAR(255), `state` VARCHAR(255), `neighborhood` VARCHAR(255), `country` VARCHAR(255), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `addresses` SELECT `id`, `city`, `state`, `neighborhood`, `country`, `created_at`, `updated_at` FROM `addresses_backup`;
Executing (default): DROP TABLE `addresses_backup`;
Executing (default): PRAGMA TABLE_INFO(`addresses`);
Executing (default): PRAGMA INDEX_LIST(`addresses`)
Executing (default): PRAGMA foreign_key_list(`addresses`)
Executing (default): CREATE TABLE IF NOT EXISTS `addresses_backup` (`id` INTEGER PRIMARY KEY, `city` VARCHAR(255), `state` VARCHAR(255), `neighborhood` VARCHAR(255), `country` VARCHAR(255), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `addresses_backup` SELECT `id`, `city`, `state`, `neighborhood`, `country`, `created_at`, `updated_at` FROM `addresses`;
Executing (default): DROP TABLE `addresses`;
Executing (default): CREATE TABLE IF NOT EXISTS `addresses` (`id` INTEGER PRIMARY KEY, `city` VARCHAR(255), `state` VARCHAR(255), `neighborhood` VARCHAR(255), `country` VARCHAR(255), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `addresses` SELECT `id`, `city`, `state`, `neighborhood`, `country`, `created_at`, `updated_at` FROM `addresses_backup`;
Executing (default): DROP TABLE `addresses_backup`;
Executing (default): PRAGMA TABLE_INFO(`addresses`);
Executing (default): PRAGMA INDEX_LIST(`addresses`)
Executing (default): PRAGMA foreign_key_list(`addresses`)
Executing (default): CREATE TABLE IF NOT EXISTS `addresses_backup` (`id` INTEGER PRIMARY KEY, `city` VARCHAR(255), `state` VARCHAR(255), `neighborhood` VARCHAR(255), `country` VARCHAR(255), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `addresses_backup` SELECT `id`, `city`, `state`, `neighborhood`, `country`, `created_at`, `updated_at` FROM `addresses`;
Executing (default): DROP TABLE `addresses`;
Executing (default): CREATE TABLE IF NOT EXISTS `addresses` (`id` INTEGER PRIMARY KEY, `city` VARCHAR(255), `state` VARCHAR(255), `neighborhood` VARCHAR(255), `country` VARCHAR(255), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `addresses` SELECT `id`, `city`, `state`, `neighborhood`, `country`, `created_at`, `updated_at` FROM `addresses_backup`;
Executing (default): DROP TABLE `addresses_backup`;
Executing (default): PRAGMA TABLE_INFO(`addresses`);
Executing (default): PRAGMA INDEX_LIST(`addresses`)
Executing (default): PRAGMA foreign_key_list(`addresses`)
Executing (default): CREATE TABLE IF NOT EXISTS `addresses_backup` (`id` INTEGER PRIMARY KEY, `city` VARCHAR(255), `state` VARCHAR(255), `neighborhood` VARCHAR(255), `country` VARCHAR(255), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `addresses_backup` SELECT `id`, `city`, `state`, `neighborhood`, `country`, `created_at`, `updated_at` FROM `addresses`;
Executing (default): DROP TABLE `addresses`;
Executing (default): CREATE TABLE IF NOT EXISTS `addresses` (`id` INTEGER PRIMARY KEY, `city` VARCHAR(255), `state` VARCHAR(255), `neighborhood` VARCHAR(255), `country` VARCHAR(255), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `addresses` SELECT `id`, `city`, `state`, `neighborhood`, `country`, `created_at`, `updated_at` FROM `addresses_backup`;
Executing (default): DROP TABLE `addresses_backup`;
Executing (default): PRAGMA INDEX_LIST(`addresses`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='expenses';
Executing (default): PRAGMA TABLE_INFO(`expenses`);
Executing (default): PRAGMA foreign_key_list(`expenses`)
Executing (default): PRAGMA INDEX_LIST(`expenses`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_expenses_1`)
Executing (default): PRAGMA foreign_key_list(`expenses`)
Executing (default): PRAGMA TABLE_INFO(`expenses`);
Executing (default): PRAGMA INDEX_LIST(`expenses`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_expenses_1`)
Executing (default): PRAGMA foreign_key_list(`expenses`)
Executing (default): CREATE TABLE IF NOT EXISTS `expenses_backup` (`id` UUID UNIQUE PRIMARY KEY, `name` VARCHAR(255), `value` FLOAT, `currency` VARCHAR(255), `date` DATETIME, `created_by` UUID REFERENCES `users` (`id`), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `expenses_backup` SELECT `id`, `name`, `value`, `currency`, `date`, `created_by`, `created_at`, `updated_at` FROM `expenses`;
Executing (default): DROP TABLE `expenses`;
Executing (default): CREATE TABLE IF NOT EXISTS `expenses` (`id` UUID UNIQUE PRIMARY KEY, `name` VARCHAR(255), `value` FLOAT, `currency` VARCHAR(255), `date` DATETIME, `created_by` UUID REFERENCES `users` (`id`), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `expenses` SELECT `id`, `name`, `value`, `currency`, `date`, `created_by`, `created_at`, `updated_at` FROM `expenses_backup`;
Executing (default): DROP TABLE `expenses_backup`;
Executing (default): PRAGMA TABLE_INFO(`expenses`);
Executing (default): PRAGMA INDEX_LIST(`expenses`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_expenses_1`)
Executing (default): PRAGMA foreign_key_list(`expenses`)
Executing (default): CREATE TABLE IF NOT EXISTS `expenses_backup` (`id` UUID UNIQUE PRIMARY KEY, `name` VARCHAR(255), `value` FLOAT, `currency` VARCHAR(255), `date` DATETIME, `created_by` UUID REFERENCES `users` (`id`), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `expenses_backup` SELECT `id`, `name`, `value`, `currency`, `date`, `created_by`, `created_at`, `updated_at` FROM `expenses`;
Executing (default): DROP TABLE `expenses`;
Executing (default): CREATE TABLE IF NOT EXISTS `expenses` (`id` UUID UNIQUE PRIMARY KEY, `name` VARCHAR(255), `value` FLOAT, `currency` VARCHAR(255), `date` DATETIME, `created_by` UUID REFERENCES `users` (`id`), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `expenses` SELECT `id`, `name`, `value`, `currency`, `date`, `created_by`, `created_at`, `updated_at` FROM `expenses_backup`;
Executing (default): DROP TABLE `expenses_backup`;
Executing (default): PRAGMA TABLE_INFO(`expenses`);
Executing (default): PRAGMA INDEX_LIST(`expenses`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_expenses_1`)
Executing (default): PRAGMA foreign_key_list(`expenses`)
Executing (default): CREATE TABLE IF NOT EXISTS `expenses_backup` (`id` UUID UNIQUE PRIMARY KEY, `name` VARCHAR(255), `value` FLOAT, `currency` VARCHAR(255), `date` DATETIME, `created_by` UUID REFERENCES `users` (`id`), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `expenses_backup` SELECT `id`, `name`, `value`, `currency`, `date`, `created_by`, `created_at`, `updated_at` FROM `expenses`;
Executing (default): DROP TABLE `expenses`;
Executing (default): CREATE TABLE IF NOT EXISTS `expenses` (`id` UUID UNIQUE PRIMARY KEY, `name` VARCHAR(255), `value` FLOAT, `currency` VARCHAR(255), `date` DATETIME, `created_by` UUID REFERENCES `users` (`id`), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `expenses` SELECT `id`, `name`, `value`, `currency`, `date`, `created_by`, `created_at`, `updated_at` FROM `expenses_backup`;
Executing (default): DROP TABLE `expenses_backup`;
Executing (default): PRAGMA TABLE_INFO(`expenses`);
Executing (default): PRAGMA INDEX_LIST(`expenses`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_expenses_1`)
Executing (default): PRAGMA foreign_key_list(`expenses`)
Executing (default): CREATE TABLE IF NOT EXISTS `expenses_backup` (`id` UUID UNIQUE PRIMARY KEY, `name` VARCHAR(255), `value` FLOAT, `currency` VARCHAR(255), `date` DATETIME, `created_by` UUID REFERENCES `users` (`id`), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `expenses_backup` SELECT `id`, `name`, `value`, `currency`, `date`, `created_by`, `created_at`, `updated_at` FROM `expenses`;
Executing (default): DROP TABLE `expenses`;
Executing (default): CREATE TABLE IF NOT EXISTS `expenses` (`id` UUID UNIQUE PRIMARY KEY, `name` VARCHAR(255), `value` FLOAT, `currency` VARCHAR(255), `date` DATETIME, `created_by` UUID REFERENCES `users` (`id`), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `expenses` SELECT `id`, `name`, `value`, `currency`, `date`, `created_by`, `created_at`, `updated_at` FROM `expenses_backup`;
Executing (default): DROP TABLE `expenses_backup`;
Executing (default): PRAGMA TABLE_INFO(`expenses`);
Executing (default): PRAGMA INDEX_LIST(`expenses`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_expenses_1`)
Executing (default): PRAGMA foreign_key_list(`expenses`)
Executing (default): CREATE TABLE IF NOT EXISTS `expenses_backup` (`id` UUID UNIQUE PRIMARY KEY, `name` VARCHAR(255), `value` FLOAT, `currency` VARCHAR(255), `date` DATETIME, `created_by` UUID REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE, `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `expenses_backup` SELECT `id`, `name`, `value`, `currency`, `date`, `created_by`, `created_at`, `updated_at` FROM `expenses`;
Executing (default): DROP TABLE `expenses`;
Executing (default): CREATE TABLE IF NOT EXISTS `expenses` (`id` UUID UNIQUE PRIMARY KEY, `name` VARCHAR(255), `value` FLOAT, `currency` VARCHAR(255), `date` DATETIME, `created_by` UUID REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE, `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `expenses` SELECT `id`, `name`, `value`, `currency`, `date`, `created_by`, `created_at`, `updated_at` FROM `expenses_backup`;
Executing (default): DROP TABLE `expenses_backup`;
Executing (default): PRAGMA TABLE_INFO(`expenses`);
Executing (default): PRAGMA INDEX_LIST(`expenses`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_expenses_1`)
Executing (default): PRAGMA foreign_key_list(`expenses`)
Executing (default): CREATE TABLE IF NOT EXISTS `expenses_backup` (`id` UUID UNIQUE PRIMARY KEY, `name` VARCHAR(255), `value` FLOAT, `currency` VARCHAR(255), `date` DATETIME, `created_by` UUID REFERENCES `users` (`id`), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `expenses_backup` SELECT `id`, `name`, `value`, `currency`, `date`, `created_by`, `created_at`, `updated_at` FROM `expenses`;
Executing (default): DROP TABLE `expenses`;
Executing (default): CREATE TABLE IF NOT EXISTS `expenses` (`id` UUID UNIQUE PRIMARY KEY, `name` VARCHAR(255), `value` FLOAT, `currency` VARCHAR(255), `date` DATETIME, `created_by` UUID REFERENCES `users` (`id`), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `expenses` SELECT `id`, `name`, `value`, `currency`, `date`, `created_by`, `created_at`, `updated_at` FROM `expenses_backup`;
Executing (default): DROP TABLE `expenses_backup`;
Executing (default): PRAGMA TABLE_INFO(`expenses`);
Executing (default): PRAGMA INDEX_LIST(`expenses`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_expenses_1`)
Executing (default): PRAGMA foreign_key_list(`expenses`)
Executing (default): CREATE TABLE IF NOT EXISTS `expenses_backup` (`id` UUID UNIQUE PRIMARY KEY, `name` VARCHAR(255), `value` FLOAT, `currency` VARCHAR(255), `date` DATETIME, `created_by` UUID REFERENCES `users` (`id`), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `expenses_backup` SELECT `id`, `name`, `value`, `currency`, `date`, `created_by`, `created_at`, `updated_at` FROM `expenses`;
Executing (default): DROP TABLE `expenses`;
Executing (default): CREATE TABLE IF NOT EXISTS `expenses` (`id` UUID UNIQUE PRIMARY KEY, `name` VARCHAR(255), `value` FLOAT, `currency` VARCHAR(255), `date` DATETIME, `created_by` UUID REFERENCES `users` (`id`), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `expenses` SELECT `id`, `name`, `value`, `currency`, `date`, `created_by`, `created_at`, `updated_at` FROM `expenses_backup`;
Executing (default): DROP TABLE `expenses_backup`;
Executing (default): PRAGMA INDEX_LIST(`expenses`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_expenses_1`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='expense_members';
Executing (default): PRAGMA TABLE_INFO(`expense_members`);
Executing (default): PRAGMA foreign_key_list(`expense_members`)
Executing (default): PRAGMA INDEX_LIST(`expense_members`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_expense_members_1`)
Executing (default): PRAGMA foreign_key_list(`expense_members`)
Executing (default): PRAGMA TABLE_INFO(`expense_members`);
Executing (default): PRAGMA INDEX_LIST(`expense_members`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_expense_members_1`)
Executing (default): PRAGMA foreign_key_list(`expense_members`)
Executing (default): CREATE TABLE IF NOT EXISTS `expense_members_backup` (`id` UUID UNIQUE PRIMARY KEY, `expense_id` UUID REFERENCES `expenses` (`id`) ON DELETE CASCADE ON UPDATE CASCADE, `user_id` UUID REFERENCES `users` (`id`), `amount_owed` FLOAT);
Executing (default): INSERT INTO `expense_members_backup` SELECT `id`, `expense_id`, `user_id`, `amount_owed` FROM `expense_members`;
Executing (default): DROP TABLE `expense_members`;
Executing (default): CREATE TABLE IF NOT EXISTS `expense_members` (`id` UUID UNIQUE PRIMARY KEY, `expense_id` UUID REFERENCES `expenses` (`id`) ON DELETE CASCADE ON UPDATE CASCADE, `user_id` UUID REFERENCES `users` (`id`), `amount_owed` FLOAT);
Executing (default): INSERT INTO `expense_members` SELECT `id`, `expense_id`, `user_id`, `amount_owed` FROM `expense_members_backup`;
Executing (default): DROP TABLE `expense_members_backup`;
Executing (default): PRAGMA TABLE_INFO(`expense_members`);
Executing (default): PRAGMA INDEX_LIST(`expense_members`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_expense_members_1`)
Executing (default): PRAGMA foreign_key_list(`expense_members`)
Executing (default): CREATE TABLE IF NOT EXISTS `expense_members_backup` (`id` UUID UNIQUE PRIMARY KEY, `expense_id` UUID REFERENCES `expenses` (`id`), `user_id` UUID REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE, `amount_owed` FLOAT);
Executing (default): INSERT INTO `expense_members_backup` SELECT `id`, `expense_id`, `user_id`, `amount_owed` FROM `expense_members`;
Executing (default): DROP TABLE `expense_members`;
Executing (default): CREATE TABLE IF NOT EXISTS `expense_members` (`id` UUID UNIQUE PRIMARY KEY, `expense_id` UUID REFERENCES `expenses` (`id`), `user_id` UUID REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE, `amount_owed` FLOAT);
Executing (default): INSERT INTO `expense_members` SELECT `id`, `expense_id`, `user_id`, `amount_owed` FROM `expense_members_backup`;
Executing (default): DROP TABLE `expense_members_backup`;
Executing (default): PRAGMA TABLE_INFO(`expense_members`);
Executing (default): PRAGMA INDEX_LIST(`expense_members`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_expense_members_1`)
Executing (default): PRAGMA foreign_key_list(`expense_members`)
Executing (default): CREATE TABLE IF NOT EXISTS `expense_members_backup` (`id` UUID UNIQUE PRIMARY KEY, `expense_id` UUID REFERENCES `expenses` (`id`), `user_id` UUID REFERENCES `users` (`id`), `amount_owed` FLOAT);
Executing (default): INSERT INTO `expense_members_backup` SELECT `id`, `expense_id`, `user_id`, `amount_owed` FROM `expense_members`;
Executing (default): DROP TABLE `expense_members`;
Executing (default): CREATE TABLE IF NOT EXISTS `expense_members` (`id` UUID UNIQUE PRIMARY KEY, `expense_id` UUID REFERENCES `expenses` (`id`), `user_id` UUID REFERENCES `users` (`id`), `amount_owed` FLOAT);
Executing (default): INSERT INTO `expense_members` SELECT `id`, `expense_id`, `user_id`, `amount_owed` FROM `expense_members_backup`;
Executing (default): DROP TABLE `expense_members_backup`;
Executing (default): PRAGMA INDEX_LIST(`expense_members`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_expense_members_1`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='users';
Executing (default): PRAGMA TABLE_INFO(`users`);
Executing (default): PRAGMA foreign_key_list(`users`)
Executing (default): PRAGMA INDEX_LIST(`users`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_users_1`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_users_2`)
Executing (default): PRAGMA foreign_key_list(`users`)
Executing (default): PRAGMA TABLE_INFO(`users`);
Executing (default): PRAGMA INDEX_LIST(`users`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_users_1`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_users_2`)
Executing (default): PRAGMA foreign_key_list(`users`)
Executing (default): CREATE TABLE IF NOT EXISTS `users_backup` (`id` UUID UNIQUE PRIMARY KEY, `email` VARCHAR(255) NOT NULL UNIQUE, `password_hash` VARCHAR(255), `default_currency` VARCHAR(255) DEFAULT 'INR', `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL);
Executing (default): INSERT INTO `users_backup` SELECT `id`, `email`, `password_hash`, `default_currency`, `created_at`, `updated_at` FROM `users`;
[SEQUELIZE] Error during database service initialization
Error
    at Database.<anonymous> (D:\Propscoh\express-sequelize-boilerplate-main\node_modules\sequelize\lib\dialects\sqlite\query.js:185:27)
    at D:\Propscoh\express-sequelize-boilerplate-main\node_modules\sequelize\lib\dialects\sqlite\query.js:183:50
    at new Promise (<anonymous>)
    at Query.run (D:\Propscoh\express-sequelize-boilerplate-main\node_modules\sequelize\lib\dialects\sqlite\query.js:183:12)
    at D:\Propscoh\express-sequelize-boilerplate-main\node_modules\sequelize\lib\sequelize.js:315:28
    at async SQLiteQueryInterface.changeColumn (D:\Propscoh\express-sequelize-boilerplate-main\node_modules\sequelize\lib\dialects\sqlite\query-interface.js:43:7)
    at async User.sync (D:\Propscoh\express-sequelize-boilerplate-main\node_modules\sequelize\lib\model.js:984:11)
    at async Sequelize.sync (D:\Propscoh\express-sequelize-boilerplate-main\node_modules\sequelize\lib\sequelize.js:377:9)
    at async Object.init (D:\Propscoh\express-sequelize-boilerplate-main\src\services\sequelize.service.js:28:7)
    at async D:\Propscoh\express-sequelize-boilerplate-main\src\index.js:12:7 {
  name: 'SequelizeUniqueConstraintError',
  errors: [
    ValidationErrorItem {
      message: 'email must be unique',
      type: 'unique violation',
      path: 'email',
      value: null,
      origin: 'DB',
      instance: null,
      validatorKey: 'not_unique',
      validatorName: null,
      validatorArgs: []
    }
  ],
  parent: [Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: users_backup.email] {
    errno: 19,
    code: 'SQLITE_CONSTRAINT',
    sql: 'INSERT INTO `users_backup` SELECT `id`, `email`, `password_hash`, `default_currency`, `created_at`, `updated_at` FROM `users`;'
  },
  original: [Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: users_backup.email] {
    errno: 19,
    code: 'SQLITE_CONSTRAINT',
    sql: 'INSERT INTO `users_backup` SELECT `id`, `email`, `password_hash`, `default_currency`, `created_at`, `updated_at` FROM `users`;'
  },
  fields: [ 'email' ],
  sql: 'INSERT INTO `users_backup` SELECT `id`, `email`, `password_hash`, `default_currency`, `created_at`, `updated_at` FROM `users`;'
}
